import math
import pandas as pd
from kolmogorov_gabor_polinomial import KolmogorovGaborPolynomial

class PolynomialNetwork:
    """
    Класс для построения и работы с полиномиальной сетью.

    Полиномиальная сеть состоит из двух слоёв:
      1. Первый слой включает несколько полиномиальных моделей (полиномов):
         - Первый полином обучается на всех признаках входного датафрейма.
         - Остальные полиномы обучаются на группах из двух признаков.
      2. Второй слой включает одну полиномиальную модель, которая обучается
         на выходах полиномов первого слоя.

    Атрибуты:
        architecture (dict): Определение архитектуры сети в формате {номер_слоя: количество_полиномов}.
        outputs (dict): Словарь, содержащий выходы обученных полиномов с ключами вида "номер_слоя_полином".
        models (dict): Словарь, где хранятся обученные модели с ключами вида "номер_слоя_полином".
        predicts (dict): Словарь для хранения промежуточных предсказаний при вызове метода predict.
    """
    def __init__(self):
        """
        Инициализация экземпляра класса PolynomialNetwork.

        Создаются пустые словари для хранения:
            - архитектуры сети,
            - выходов полиномов,
            - обученных моделей,
            - промежуточных предсказаний.
        """
        self.architecture = {}  # {номер слоя: количество полиномов в слое}
        self.outputs = {}       # {"номер_слоя_полином": предсказания после обучения}
        self.models = {}        # {"номер_слоя_полином": экземпляр KolmogorovGaborPolynomial}
        self.predicts = {}      # {"номер_слоя_полином": предсказания при вызове метода predict}

    def fit(self, X, Y):
        """
        Обучает полиномиальную сеть на входных данных X с целевой переменной Y.

        Шаги обучения:
          1. Определение архитектуры:
             - Первый слой: количество полиномов = ceil(число признаков / 2) + 1.
             - Второй слой: 1 полином.
          2. Обучение полиномов первого слоя:
             - Первый полином обучается на всех признаках X.
             - Остальные полиномы обучаются на подмножествах признаков, группируя их по 2.
          3. Обучение полинома второго слоя:
             - На вход второго слоя подаются предсказания всех полиномов первого слоя.

        Аргументы:
            X (pandas.DataFrame): Датафрейм с входными признаками.
            Y (pandas.Series или pandas.DataFrame): Целевая переменная.
        """
        num_columns = X.shape[1]  # Получаем число признаков

        # Определение архитектуры сети:
        # Первый слой: ceil(число признаков / 2) + 1 полиномов
        self.architecture[1] = math.ceil(num_columns / 2) + 1  
        # Второй слой: 1 полином
        self.architecture[2] = 1  

        # Обучение полиномов первого слоя
        for p in range(1, self.architecture[1] + 1):
            if p == 1:
                # Первый полином обучается на всех признаках
                current_data = X
            else:
                # Остальные полиномы обучаются на группах по 2 признака.
                # Определяем начальный и конечный индекс для среза столбцов.
                start_idx = (p - 2) * 2
                end_idx = min(start_idx + 2, num_columns)
                current_data = X.iloc[:, start_idx:end_idx]

            # Создаем экземпляр полиномиальной модели
            polynomial = KolmogorovGaborPolynomial()
            # Обучаем модель на выбранном наборе признаков и целевой переменной
            polynomial.fit(current_data, Y)
            # Получаем предсказания обученной модели для данных, на которых она обучалась
            predictions = polynomial.predict(current_data)

            # Формируем ключ для хранения модели и ее предсказаний (например, "1_1", "1_2" и т.д.)
            key = f"1_{p}"
            # Преобразуем предсказания в одномерный массив и сохраняем как Series с индексом Y
            self.outputs[key] = pd.Series(predictions.to_numpy().ravel(), index=Y.index)
            # Сохраняем модель в словаре models
            self.models[key] = polynomial

        # Обучение второго слоя
        # Формируем вход для второго слоя, объединяя выходы всех полиномов первого слоя
        layer_2_input = pd.concat(
            [self.outputs[f"1_{p}"] for p in range(1, self.architecture[1] + 1)],
            axis=1
        )
        # Создаем и обучаем полиномиальную модель для второго слоя
        polynomial = KolmogorovGaborPolynomial()
        polynomial.fit(layer_2_input, Y)
        predictions = polynomial.predict(layer_2_input)

        key = "2_1"  # Ключ для модели второго слоя
        # Преобразуем предсказания в одномерный массив и сохраняем
        self.outputs[key] = pd.Series(predictions.to_numpy().ravel(), index=Y.index)
        self.models[key] = polynomial  # Сохраняем модель второго слоя

    def predict(self, X):
        """
        Делает предсказания для новых входных данных X с использованием обученной полиномиальной сети.

        Шаги предсказания:
          1. Получение предсказаний от полиномов первого слоя:
             - Первый полином использует все признаки.
             - Остальные полиномы используют группы по 2 признака.
          2. Формирование входа для второго слоя:
             - Объединяются предсказания первого слоя в один DataFrame.
          3. Получение финальных предсказаний от модели второго слоя.

        Аргументы:
            X (pandas.DataFrame): Новый датафрейм с входными признаками.

        Возвращает:
            pandas.Series: Финальные предсказания модели, приведённые к одномерному массиву.
        """
        self.predicts = {}  # Сброс временного словаря предсказаний
        num_columns = X.shape[1]  # Количество признаков во входных данных

        # Получение предсказаний первого слоя
        for p in range(1, self.architecture[1] + 1):
            if p == 1:
                # Первый полином использует все признаки
                current_data = X
            else:
                # Остальные полиномы используют группы признаков по 2 столбца
                start_idx = (p - 2) * 2
                end_idx = min(start_idx + 2, num_columns)
                current_data = X.iloc[:, start_idx:end_idx]

            key = f"1_{p}"  # Ключ для соответствующей модели первого слоя
            polynomial = self.models[key]  # Извлекаем обученную модель
            predictions = polynomial.predict(current_data)  # Получаем предсказания

            # Преобразуем предсказания в одномерный массив и сохраняем как Series с индексом X
            self.predicts[key] = pd.Series(predictions.to_numpy().ravel(), index=X.index)

        # Формирование входа для второго слоя путем объединения всех предсказаний первого слоя
        layer_2_input = pd.concat(
            [self.predicts[f"1_{p}"] for p in range(1, self.architecture[1] + 1)],
            axis=1
        )
        key = "2_1"  # Ключ для модели второго слоя
        polynomial = self.models[key]  # Извлекаем модель второго слоя
        final_predictions = polynomial.predict(layer_2_input)  # Получаем финальные предсказания

        # Возвращаем предсказания в виде одномерного Series с сохранением индексов входных данных
        return pd.Series(final_predictions.to_numpy().ravel(), index=X.index)


# Вывод сообщения об успешном добавлении класса полиномиальной сети
print('Polynomial network class added successfully!')
